#' @title Train a prediction model
#' @description Trains a prediction model from an \code{scPred} object stored in a \code{Seurat} object
#' @param object An \code{Seurat} object with informative PCs obtained using
#' the \code{getFeatureSpace} function
#' @param model Classification model supported via \code{caret} package. A list of all models can be found here:
#' https://topepo.github.io/caret/available-models.html
#' Default: support vector machine with radial kernel
#' @param resampleMethod Resample model used in \code{trainControl} function from \code{caret}. 
#' Default: K-fold cross validation
#' @param number Number of iterations for resample method. See \code{trainControl} function
#' @param seed Numeric seed for resample method. Fixed to ensure reproducibility
#' @param tuneLength An integer denoting the amount of granularity in the tuning parameter grid. 
#' By default, this argument is the number of levels for each tuning parameters that should be generated by train.
#' See `?caret::train` documentation
#' @param metric Performance metric to be used to select best model: `ROC` (area under the ROC curve), 
#' `PR` (area under the precision-recall curve), `Accuracy`, and `Kappa`
#' @param returnData If \code{TRUE}, training data is returned within \code{scPred} object. 
#' @param savePredictions Specifies the set of hold-out predictions for each resample that should be
#' returned. Values can be either "all", "final", or "none".
#' @return A list of \code{train} objects for each cell class (e.g. cell type). See \code{train} function for details.
#' @keywords train, model
#' @importFrom methods is
#' @importFrom caret trainControl prSummary train twoClassSummary
#' @importFrom pbapply pblapply
#' @export
#' @author
#' Jose Alquicira Hernandez
#' @examples
#'
#' # Train a SVM with a Radial kernel
#' ## A numeric seed is provided for the K-fold cross validation
#' ## The metric ROC is used to select the best tuned model. "Accuracy" and "Kappa" may be used too.
#'
#' pbmc_small <- getFeatureSpace(pbmc_small, "RNA_snn_res.0.8")
#' pbmc_small <- trainModel(object = pbmc_small,
#'                      seed = 1234,
#'                      metric = "ROC")
#'

trainModel <- function(object,
                       model = "svmRadial",
                       resampleMethod = "cv",
                       number = 5,
                       seed = 66,
                       tuneLength = 3,
                       metric = c("ROC", "PR", "Accuracy", "Kappa"),
                       returnData = FALSE,
                       savePredictions = "final",
                       allowParallel = FALSE
){
    
    
    # Validations -------------------------------------------------------------
    
    # Check class
    if(!is(object, "Seurat")){
        stop("object must be 'Seurat'")
    }
    
    if(is.null(object@misc$scPred)){
        stop("No features have been determined. Use 'getFeatureSpace()' function")
    }
    
    classes <- names(object@misc$scPred@features)
    metric <- match.arg(metric)
    
    
    # Train a prediction model for each class
    cat(crayon::green(cli::symbol$record, " Training models for each cell type...\n"))
    
    if(length(classes) == 1){
        modelsRes <-  .trainModel(classes[1],
                                  object,
                                  model,
                                  resampleMethod,
                                  tuneLength,
                                  seed,
                                  metric,
                                  number,
                                  returnData,
                                  savePredictions,
                                  allowParallel)
        modelsRes <- list(modelsRes)
        names(modelsRes) <- classes[1]
        
        
    }else{
        modelsRes <- pblapply(classes, .trainModel,
                              object,
                              model,
                              resampleMethod,
                              tuneLength,
                              seed,
                              metric,
                              number,
                              returnData,
                              savePredictions,
                              allowParallel)
        names(modelsRes) <- classes
    }
    
    cat(crayon::green("DONE!\n"))
    
    object@misc$scPred@train <- modelsRes
    object
}

.trainModel <- function(positiveClass,
                        object,
                        model,
                        resampleMethod,
                        tuneLength,
                        seed,
                        metric,
                        number,
                        returnData,
                        savePredictions, 
                        allowParallel){
    
    
    
    
    if(nrow(object@misc$scPred@features[[positiveClass]]) == 0){
        message("No informative principal components were identified for class: ", positiveClass)
    }
    
    namesPC <- as.character(object@misc$scPred@features[[positiveClass]]$PC)
    features <- subsetMatrix(Embeddings(object, reduction = "pca"), namesPC)
    response <-  object@meta.data[, "scPred_response", drop = TRUE] %>% as.character()
    
    
    i <- response != positiveClass
    response[i] <- "other"
    response <- factor(response, levels = c(positiveClass, "other"))
    
    
    if(!is.null(seed)) set.seed(seed)
    
    if(metric == "ROC"){
        trCtrl <- trainControl(classProbs = TRUE,
                               method = resampleMethod,
                               number = number,
                               summaryFunction = twoClassSummary,
                               returnData = returnData,
                               savePredictions = savePredictions,
                               allowParallel = allowParallel)
        
    }else if(metric == "PR"){
        trCtrl <- trainControl(classProbs = TRUE,
                               method = resampleMethod,
                               number = number,
                               summaryFunction = prSummary,
                               returnData = returnData,
                               savePredictions = savePredictions,
                               allowParallel = allowParallel)
        metric <- "AUC"
    }else{
        trCtrl <- trainControl(classProbs = TRUE,
                               method = resampleMethod,
                               number = number,
                               returnData = returnData,
                               savePredictions = savePredictions,
                               allowParallel = allowParallel)
    }
    
    
    if(metric == "AUC"){
        fit <- train(x = features,
                     y = response,
                     method = model,
                     metric = metric,
                     trControl = trCtrl,
                     preProc = c("center", "scale"), 
                     tuneLength = tuneLength)
    }else{
        fit <- train(x = features,
                     y = response,
                     method = model,
                     preProc = c("center", "scale"),
                     metric = metric,
                     trControl = trCtrl, 
                     tuneLength = tuneLength)
    }
    
    fit
}




